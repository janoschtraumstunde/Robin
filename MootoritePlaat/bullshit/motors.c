#include "motors.h"

Motor* newMotor(REG_PTR pwm, uint8_t dir_pin, REG_PTR dir_port, uint8_t forwardDirection)
{
	Motor* m = (Motor*)malloc(sizeof(Motor));
	m->pwm = pwm;
	m->dir_pin = dir_pin;
	m->dir_port = dir_port;
	m->fwd_dir = forwardDirection;
	return m;
}

uint8_t getPwmMode()	{ return __pwm_mode; }
uint8_t getPrescaling() { return __prescaling; }


void pwm_mode(uint8_t pwm_mode, uint8_t prescaler){
	/*@note:
		@pdf # - check the # page in ATmega datasheet for more details
 
		The PWM is generated by two timers: timer_0 and timer_2
		The timer settings in the Timer Counter Control Registers (TCCR)-s
		for specific PWM modes are described below:
	*/
 
	// validate pwm and prescaler
	if(1 <= pwm_mode && pwm_mode <= 2) 
		__pwm_mode = pwm_mode;
	if(1 <= prescaler && prescaler <= 5)
		__prescaling = prescaler;
 
	switch(__pwm_mode) 
	{
	case PWM_MODE_FAST:
		// FAST PWM MODE
		/* @pdf 104
			set 10 10 00 11
			10 - clear OC0A on compare match
			10 - clear OC0B on compare match
			00 - not used
			11 - Fast PWM mode
		*/
		TCCR0A = 0b10100011; // = 0xa3;
		/* @pdf 107
			set 00 00 0 ###
			00 - these bits must be set zero for PWM mode
			00 - not used
			0 - 0 for any simple PWM (upcounts to 0xFF)
			### - 001 = No prescaling, 010 = 8, 011 = 64, 100 = 256, 101 = 1024
		*/
		TCCR0B = __prescaling;
 
		// similar settings as above, but:
		// clear OC2A on match, clear OC2B on match
		TCCR2A = 0b10100011;
		TCCR2B = __prescaling;
		break;
	case PWM_MODE_PHASE_CORRECT:
		// PHASE CORRECT PWM MODE
		/* @pdf 105
			set 10 10 00 01
			10 - Clear OC0A on Compare Match when up-counting. Set OC0A on Compare Match when down-counting.
			10 - Clear OC0B on Compare Match when up-counting. Set OC0B on Compare Match when down-counting.
			00 - not used
			01 - PWM, Phase Correct
		*/
		TCCR0A = 0b10100001;
		/* @pdf 107
			set 00 00 0 001
			00 - these bits must be set zero for PWM mode
			00 - not used
			0 - 0 for any simple PWM (upcounts to 0xFF)
			001 - No prescaling
		*/
		TCCR0B = __prescaling;
 
		// similar settings as above, but for OC2A and OC2B
		TCCR2A = 0b10100001;
		TCCR2B = __prescaling;
		break;
	}
 
}
 
/* Sets the decay mode of the motors.
   Possible options:
	DECAY_MODE_FAST
	DECAY_MODE_SLOW
*/
void set_decay_mode(uint8_t DECAY_MODE_){

	/*@note PORTC, pin PC7 (7) sets the
	 decay mode
	 */
	switch(DECAY_MODE_) {
	case DECAY_MODE_FAST: // 0
		output_lo(&PORTC, PC7);
		break;
	case DECAY_MODE_SLOW: // 1
		output_hi(&PORTC, PC7);
		break;
	}
}
 
/* Initializes the motors */


void init_motors(uint8_t PWM_MODE_, uint8_t PRESCALING_){

	pwm_mode(PWM_MODE_, PRESCALING_);
 
	motors[0] =	newMotor(&OCR0A, M0_DIR, &PORTA, M0_FWD);
	motors[1] =	newMotor(&OCR0B, M1_DIR, &PORTA, M1_FWD);
	motors[2] =	newMotor(&OCR2A, M2_DIR, &PORTC, M2_FWD);
	motors[3] =	newMotor(&OCR2B, M3_DIR, &PORTC, M3_FWD);
 
	// Set port pins to 'output' mode (1)
	output_hi(&DDRA, M0_DIR); //PA2
    output_hi(&DDRB, M0_PWM); //PB3 -> OC0A
    output_hi(&DDRA, M1_DIR); //PA3
    output_hi(&DDRB, M1_PWM); //PB4 -> OC0B
    output_hi(&DDRC, M2_DIR); //PC5 
    output_hi(&DDRD, M2_PWM); //PD7 -> OC2A
	output_hi(&DDRC, M3_DIR); //PC4 
	output_hi(&DDRD, M3_PWM); //PD6 -> OC2B
}






 
